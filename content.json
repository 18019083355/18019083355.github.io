[{"title":"HTTP中GET与POST的区别","date":"2017-09-13T07:09:05.000Z","path":"2017/09/13/HTTP中GET与POST的区别/","text":"概述GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。 当你在面试中被问到这个问题，你的内心充满了自信和喜悦。 你轻轻松松的给出了一个“标准答案”：GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 “很遗憾，这不是我们要的回答!” 请告诉我真相。。。 如果我告诉你GET和POST本质上没有区别你信吗? 让我们扒下GET和POST的外衣，坦诚相见吧! GET和POST是什么?HTTP协议中的两种发送请求的方法。 HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事? 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢? 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了? 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘?当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包;POST产生两个TCP数据包。 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么? GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的?","tags":[]},{"title":"TCP/IP、Http、Socket的区别","date":"2017-09-12T03:47:33.000Z","path":"2017/09/12/TCP-IP、Http、Socket的区别/","text":"TCP/IP、Http、Socket的区别概述网络由下往上分为 物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 通过初步的了解，我知道IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层， 三者从本质上来说没有可比性， socket则是对TCP/IP协议的封装和应用(程序员层面上)。 也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输， 而HTTP是应用层协议，主要解决如何包装数据。 关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍： “我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。 如果想要使传输的数据有意义，则必须使用到应用层协议。 应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。 WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。“ 而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。 通过Socket，我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。 Socket编程接口在设计的时候，就希望也能适应其他的网络协议。 所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象， 从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。 网络有一段关于socket和TCP/IP协议关系的说法比较容易理解： “TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。 这个就像操作系统会提供标准的编程接口，比如win32编程接口一样， TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。” 关于TCP/IP协议的相关只是，用博大精深来讲我想也不为过，单单查一下网上关于此类只是的资料和书籍文献的数量就知道， 这个我打算会买一些经典的书籍(比如《TCP/IP详解：卷一、卷二、卷三》)进行学习，今天就先总结一些基于基于TCP/IP协议的应用和编程接口的知识，也就是刚才说了很多的HTTP和Socket。 CSDN上有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。 实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。 下面是一些经常在笔试或者面试中碰到的重要的概念，特在此做摘抄和总结。 一、什么是TCP连接的三次握手 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认; 第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态; 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开) 二、利用Socket建立网络连接的步骤建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket 。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。 为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 三、HTTP链接的特点HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。 四、TCP和UDP的区别1、TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性; 而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。 2、也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。 知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的， 因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的， 即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。","tags":[]},{"title":"创建TCP服务器","date":"2017-09-11T12:46:21.000Z","path":"2017/09/11/创建TCP服务器/","text":"创建TCP服务器新建一个server.php文件1vi server.php 12345678910111213141516171819202122232425//开启两个进程$serv-&gt;set([ &apos;worker_num&apos; =&gt; 2,]);//创建Server对象，监听 127.0.0.1:9501端口$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501); //监听连接进入事件$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);//监听数据接收事件$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);//监听连接关闭事件$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);//启动服务器$serv-&gt;start(); 这里就创建了一个TCP服务器，监听本机9501端口。它的逻辑很简单，当客户端Socket通过网络发送一个 hello 字符串时，服务器会回复一个 Server: hello 字符串。 执行程序1php server.php 在命令行下运行server.php程序，启动成功后可以使用 netstat 工具看到，已经在监听9501端口。这时就可以使用telnet/netcat工具连接服务器。123telnet 127.0.0.1 9501helloServer: hello 注意：没有安装telnet的可以运行以下代码安装1yum install telnet -y 注意：关闭telnet命令12ctrl+]telnet&gt; quit 输入CTRL+]后再输入quit即可 查看server监听端口状态12netstat -an| grep 9501tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN","tags":[]},{"title":"swoole编译安装","date":"2017-09-11T11:39:01.000Z","path":"2017/09/11/swoole编译安装/","text":"swoole编译安装Swoole扩展是按照php标准扩展构建的。使用phpize来生成php编译配置，./configure来做编译配置检测，make进行编译，make install进行安装。 请下载releases版本的swoole，直接从github主干上拉取最新代码可能会编译不过 如果当前用户不是root，可能没有php目录的写权限，安装时需要sudo或者su 如果是在git分支上直接git pull更新代码，重新编译前务必要执行make clean 安装准备安装swoole前必须保证系统已经安装了下列软件12345php-5.3.10 或更高版本gcc-4.4 或更高版本makeautoconfpcre (centos系统可以执行命令：yum install pcre-devel) 全部可以yum安装 下载地址 https://github.com/swoole/swoole-src/releases http://pecl.php.net/package/swoole http://git.oschina.net/swoole/swoole 下载源代码包后，在终端进入源码目录，执行下面的命令进行编译和安装12345cd swoolephpize./configuremake sudo make install 注意：phpize属于php-devel的内容在centos中只要运行如下命令安装：1yum install php-devel PECLswoole项目已收录到PHP官方扩展库，除了手工下载编译外，还可以通过PHP官方提供的pecl命令，一键下载安装swoole1pecl install swoole 配置php.ini编译安装成功后，修改php.ini加入1extension=swoole.so 通过$ php -m | grep swoole或phpinfo()来查看是否成功加载了swoole，如果没有可能是php.ini的路径不对，可以使用php -i |grep php.ini来定位到php.ini的绝对路径 查看版本123php --ri swoole | grep Version#结果Version =&gt; 1.9.6 编译升级编译升级，只需要从pecl官网下载最新的稳定版，按照我们一开始的编译安装步骤再走一遍就完事了。之前安装的版本不需要过问，这就相当于重新安装一次新版本就好了。 友情提醒，尽可能的下载稳定版，非稳定版可能会发生很多意外的事。 pecl升级这个更简单，一条命令搞定1pecl upgrade swoole","tags":[]},{"title":"swoole环境依赖","date":"2017-09-11T11:03:16.000Z","path":"2017/09/11/swoole环境依赖/","text":"swoole环境依赖仅支持Linux，FreeBSD，MacOS，3类操作系统 Linux内核版本2.3.32以上 PHP-5.3.10以上版本，包括PHP7 gcc4.4以上版本或者clang cmake2.4+，编译为libswoole.so作为C/C++库时需要使用cmake 建议使用Ubuntu14、CentOS7或更高版本的操作系统 PHP版本依赖 仅支持PHP-5.3.10或更高版本 不依赖PHP的stream、sockets、pcntl、posix、sysvmsg等扩展。PHP只需安装最基本的扩展即可 推荐使用的Linux发行版 CentOS6.2+ Ubuntu12+ Debian6+ ARM平台（树莓派Raspberry PI） 请使用swoole-1.7.10或更高版本 使用GCC交叉编译 在编译Swoole时，需要手工修改Makefile去掉-O2编译参数 MIPS平台（OpenWrt路由器） 请使用swoole-1.7.21或更高版本 使用GCC交叉编译 CygWin环境支持（Windows系统）swoole-1.7.7增加了对cygwin环境的支持，在Windows环境下，可以直接使用cygwin + php 来跑swoole程序。 安装cygwin，并安装gcc、make、autoconf、php 4个包 下载swoole源码，在cygwin-shell中进行phpize/configure/make/make install 修改php.ini，加入swoole.so cygwin模式下需要对PHP进行简化，去掉不使用的扩展，避免进程占用内存过大，导致Fork操作失败 BashOnWindowsWindows 10系统增加了Linux子系统支持，BashOnWindows环境下也可以使用swoole。安装命令12345apt-get install libpcre3 libpcre3-dev php5 php5-dev php5-cli php5-fpm php5-curl php5-mysql php5-intl php5-xmlrpc php5-geoip php5-mysqlnd php5-mcrypt php5-memcached php5-redis php5-tidy php5-sqlite php5-json php5-gmp php5-gd php5-readline php5-imagickpecl install swooleecho &apos;extension=swoole.so&apos; &gt;&gt; /usr/php5/mods-available/swoole.inicd /usr/php5/cli/conf.d/ &amp;&amp; ln -s ../../mods-available/swoole.ini 20-swoole.inicd /usr/php5/fpm/conf.d/ &amp;&amp; ln -s ../../mods-available/swoole.ini 20-swoole.ini BashOnWindows环境下必须关闭daemonize选项 需要修改config.h关闭HAVE_SIGNALFD DockerOnWindows在Windows下开发可以使用Hyper-V+Docker来方便的开发Swoole应用，安装好Docker后再Settings里的Shared Droves 选项里共享代码所在磁盘。然后使用如下命令来快速启动Docker容器1docker run --rm -t -i --name myapp -p 9501:9501 -v e:/path/to:/app:rw xutongle/php:7.1-fpm /bin/bash e:/path/to为源码所在路径 /app 为容器内路径 在bash里执行 cd /app &amp;&amp; php server.php","tags":[]},{"title":"swoole入门","date":"2017-09-11T10:36:21.000Z","path":"2017/09/11/swoole入门/","text":"swoole入门指引概述Swoole虽然是标准的PHP扩展，实际上与普通的扩展不同。普通的扩展只是提供一个库函数。而swoole扩展在运行后会接管PHP的控制权，进入事件循环。当IO事件发生后，swoole会自动回调指定的PHP函数。Swoole要求使用者必须具备一定的Linux/Unix环境编程基础，《学习Swoole需要掌握哪些基础知识》 本文列出了基础知识清单。 swoole_server强大的TCP/UDP Server框架，多线程，EventLoop，事件驱动，异步，Worker进程组，Task异步任务，毫秒定时器，SSL/TLS隧道加密。 swoole_http_server 是 swoole_server 的子类，内置了Http的支持 swoole_websocket_server 是 swoole_http_server的子类，内置了WebSocket的支持 swoole_redis_server 是 swoole_server的子类，内置了Redis服务器端协议的支持 子类可以调用父类的所有方法和属性 swoole_clientTCP/UDP/UnixSocket客户端，支持IPv4/IPv6，支持SSL/TLS隧道加密，支持SSL客户端整数，支持同步并发调用，也支持异步事件驱动编程。 swoole_eventEventLoop API，让用户可以直接操作底层的事件循环，将socket，stream，管道等Linux文件加入到事件循环中。 eventloop接口仅可用于socket类型的文件描述符，不能用于磁盘文件读写 swoole_async异步IO接口，提供了 异步文件系统IO，定时器，异步DNS查询，异步MySQL等API，异步Http客户端，异步Redis客户端。 swoole_timer 异步毫秒定时器，可以实现间隔时间或一次性的定时任务 swoole_async_read/swoole_async_write 文件系统操作的异步接口 swoole_process进程管理模块，可以方便的创建子进程，进程间通信，进程管理。 swoole_buffer强大的内存区管理工具，像C一样进行指针计算，又无需关心内存的申请和释放，而且不用担心内存越界，底层全部做好了。 swoole_table基于共享内存和自旋锁实现的超高性能内存表。彻底解决线程，进程间数据共享，加锁同步等问题。 swoole_table的性能可以达到单线程每秒读写100W次","tags":[]},{"title":"linux搭建svn仓库","date":"2017-09-11T09:35:15.000Z","path":"2017/09/11/linux搭建svn仓库/","text":"centOs搭建svn仓库1、yum安装svn1yum install subversion 2、查看版本是否安装成功1/usr/bin/svnversion --version 3、创建svn版本库目录1mkdir -p /var/svn/svnrepos 4、创建版本库1svnadmin create /var/svn/svnrepos 5、进入conf目录（该svn版本库配置文件）authz文件是权限控制文件 passwd是帐号密码文件 svnserve.conf SVN服务配置文件 6、设置帐号密码1vi passwd 在[users]块中添加用户和密码，格式：帐号=密码，如dan=dan 7、设置权限1vi authz 在末尾添加如下代码：12[/]dan=rw 意思是版本库的根目录dan对其有读写权限 8、修改svnserve.conf文件1vi svnserve.conf 打开下面的几个注释：anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz #使用哪个文件作为权限文件realm = /var/svn/svnrepos # 认证空间名，版本库所在目录 9、启动svn版本库默认端口36901svnserve -d -r /var/svn/svnrepos --listen-port 3690 10、查看进程使用端口号及结束进程1sudo netstat -ntlp 1可以使用sudo kill -9 pid 结束进程 11、如果本地checkout连接失败，请查看防火墙3690端口是否开启1vi /etc/sysconfig/iptables 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT","tags":[]},{"title":"linux搭建lamp环境","date":"2017-09-11T06:24:09.000Z","path":"2017/09/11/linux搭建lamp环境/","text":"centOs6.4搭建lamp环境1、更新yum安装包1rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm 2、yum安装php及其扩展(7.0)1yum -y install php70w php70w-cli php70w-common php70w-gd php70w-ldap php70w-mbstring php70w-libmcrypt php70w-mysql php70w-pdo php70w-fpm 3、yum安装mysql和apache及扩展1yum -y install httpd mysql mysql-server httpd-manual mod_ssl mod_perl mod_auth_mysql mysql-connector-odbc mysql-devel libdbi-dbd-mysql 4、启动mysql服务器1service mysqld restart 5、默认密码为空，修改密码1update mysql.user set password=&apos;密码&apos; where User=&apos;root&apos; and Host=&apos;localhost&apos;; 6、配置远程连接数据库的权限1grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option; 注意： 其中.表示所有数据库的所有表’root’@’%’表示用户名为root所有ip都可以连接 7、开启防火墙1vi /etc/sysconfig/iptables 添加12-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT 至22端口后面 8、开启apache服务器1service httpd start 9、设置apache开机启动1chkconfig httpd on","tags":[]},{"title":"TP中发送邮件，并附加excel表格附件","date":"2017-07-24T07:16:45.000Z","path":"2017/07/24/TP中发送邮件，并附加excel表格附件/","text":"TP中发送邮件，并附加excel表格附件1、编写调用方法在common文件夹下新建function.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function sendmail($to, $name, $subject = &apos;&apos;, $body = &apos;&apos;, $file = null)&#123; vendor(&apos;PHPMailer.smtp&apos;, null, &apos;.class.php&apos;); vendor(&apos;PHPMailer.phpmailer&apos;, null, &apos;.class.php&apos;); $mail = new \\PHPMailer(); //PHPMailer对象 $mail-&gt;CharSet = &apos;UTF-8&apos;; //设定邮件编码，默认ISO-8859-1，如果发中文此项必须设置，否则乱码 $mail-&gt;IsSMTP(); // 设定使用SMTP服务 $mail-&gt;SMTPDebug = 0; // 关闭SMTP调试功能 // 1 = errors and messages // 2 = messages only $mail-&gt;SMTPAuth = true; // 启用 SMTP 验证功能 $mail-&gt;SMTPSecure = &apos;ssl&apos;; // 使用安全协议 $mail-&gt;Host = $config[&apos;smtp&apos;]; // SMTP 服务器 $mail-&gt;Port = 465; // SMTP服务器的端口号 $mail-&gt;Username = $config[&apos;mail&apos;]; // SMTP服务器用户名 $mail-&gt;Password = $config[&apos;pass&apos;]; // SMTP服务器密码 $mail-&gt;SetFrom($config[&apos;mail&apos;], $config[&apos;nick&apos;]); $replyEmail = &apos;&apos;; $replyName = &apos;&apos;; $mail-&gt;AddReplyTo($replyEmail, $replyName); $mail-&gt;Subject = $subject; $mail-&gt;AltBody = &quot;为了查看该邮件，请切换到支持 HTML 的邮件客户端&quot;; $mail-&gt;MsgHTML($body); $mail-&gt;AddAddress($to, $name); is_file($file) &amp;&amp; $mail-&gt;AddAttachment($file,&apos;xxxxxx.xls&apos;); //添加附件并转为xls格式 return $mail-&gt;Send();&#125;","tags":[]},{"title":"svn与git的区别","date":"2017-06-27T12:04:11.000Z","path":"2017/06/27/svn与git的区别/","text":"这篇主要是谈谈两者的区别，至于谁优谁劣看官自己思考吧！ 把第一条理解到位思想到位了做起来才会有的放矢，其他几条都是用的时候才能体会到 1) 最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。 从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。 2)Git把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。 3) Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。 4) Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 5) Git下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。 6) 刚开始用时很狗血的一点，SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。 7) 克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！ 8) 版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！ 9)分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来进行破坏工作（安检测试），那将会像传染病一样,你改一个分支，还得让其他人重新切分支重新下载，十分狗血。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可。无痛无痒。 Git的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。 最值得一提，我可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支。） 10)提交（Commit）在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。 最后总结一下： SVN的特点是简单，只是需要一个放代码的地方时用是OK的。 Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。","tags":[]},{"title":"gitlab的使用","date":"2017-06-09T03:18:31.000Z","path":"2017/06/09/gitlab的使用/","text":"gitlab的使用1、创建用户使用root用户登陆gitlab，右上角点击Admin area 然后点击中间New User，输入name、username、emial，拉到最下方Create User 这时候，如果邮箱配置正确，gitlab会往你填写的邮箱发送一份邮件 注意： login：是登陆账号 password:是第一次登陆的密码，登陆后会自动让你修改 点击Click here to login直接跳转登陆页面 2、创建项目使用新创建的用户登陆，右上角点击New project 为了方便测试Visibility Level可以选择Public 3、添加SSH Keys项目创建完成后点击右上角Profile settings，在最上方一行点击SSH Keys 把自己以及小伙伴们的SSH Keys添加进来，类似于这样 3、本地建立git仓库托管于gitlab到这里就不啰嗦了，建立仓库的步骤在创建项目的时候有教 如果还不会本地建立仓库的，可以看下我的另一篇攻略：git技术分享","tags":[]},{"title":"搭建自己的gitlab服务器","date":"2017-06-09T02:44:48.000Z","path":"2017/06/09/搭建自己的gitlab服务器/","text":"ubuntu14.04 安装gitlab概述GitLab 是一个用于仓库管理系统的开源项目。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。它提供Git版本控制、代码检查、Bug跟踪和Wiki，它可以通过LDAP或活动目录来进行安全认证和授权。单个GitLab可以支持25000个用户，同时它也可以通过设置多台服务器来实现其高可用性。GitLab并没有被收入到Ubuntu14.04软件库中，但安装GitLab却也十分方便，下面讲讲如何安装GitLab： 1、下载ubuntu14.04镜像文件我自己找了很久找到的非常快，非传齐全的开源镜像站： 传送门：网易开源镜像站 选择ubuntu-releases/ 选择14.04版本 建议选择ubuntu-14.04.5-desktop-amd64.iso这是桌面版64位 2、下载完成后安装到VM虚拟机提示：CTRL+ALT+F1和CTRL+ALT+F7可以在图形与命令界面之间切换 3、下载gitlab相关的文件 gitlab 1wget -c https://downloads-packages.s3.amazonaws.com/ubuntu-14.04/gitlab_7.0.0-omnibus-1_amd64.deb openssh 1sudo apt-get install openssh-server 邮箱服务 1sudo apt-get install postfix 安装 1sudo dpkg -i gitlab_7.0.0-omnibus-1_amd64.deb 4、设置GitLab的域名：1234sudo mkdir -p /etc/gitlabsudo touch /etc/gitlab/gitlab.rbsudo chmod 600 /etc/gitlab/gitlab.rbsudo vi /etc/gitlab/gitlab.rb 5、添加域名和邮箱配置123456789101112external_url &apos;http://192.168.1.110&apos;gitlab_rails[&apos;smtp_enable&apos;] = truegitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.163.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 25 gitlab_rails[&apos;smtp_user_name&apos;] = &quot;18019083355@163.com&quot;gitlab_rails[&apos;smtp_password&apos;] = &quot;yin359484005&quot;gitlab_rails[&apos;smtp_domain&apos;] = &quot;163.com&quot;gitlab_rails[&apos;smtp_authentication&apos;] = :logingitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;gitlab_email_from&apos;] = &quot;18019083355@163.com&quot;user[&quot;git_user_email&quot;] = &quot;18019083355@163.com&quot; 注意：参数请自行修改 6、对GitLab进行重配置1sudo gitlab-ctl reconfigure 7、检测是否安装成功1sudo gitlab-ctl status 出现如下相似结果，恭喜你已安装成功123456[sudo] password for firehare: run: nginx: (pid 13334) 16103s; run: log: (pid 4244) 22211srun: postgresql: (pid 4153) 22280s; run: log: (pid 4152) 22280srun: redis: (pid 4070) 22291s; run: log: (pid 4069) 22291srun: sidekiq: (pid 4234) 22212s; run: log: (pid 4233) 22212srun: unicorn: (pid 4212) 22218s; run: log: (pid 4211) 22218s 8、打开浏览器进入gitlab后台 虚拟机访问localhost 本地访问192.168.1.110 默认管理员账号密码： 1Username: root Password: 5iveL!fe 第一次登陆后会自动让你修改密码 注意： IP地址请自行修改","tags":[]},{"title":"linux下的数据备份","date":"2017-06-05T03:41:49.000Z","path":"2017/06/05/linux下的数据备份/","text":"linux下如何实现mysql数据库每天自动备份定时备份概述备份是容灾的基础，是指为防止系统出现操作失误或系统故障导致数据丢失，而将全部或部分数据集合从应用主机的硬盘或阵列复制到其它的存储介质的过程。而对于一些网站、系统来说，数据库就是一切，所以做好数据库的备份是至关重要的！ 1、查看磁盘空间情况：既然是定时备份，就要选择一个空间充足的磁盘空间，避免出现因空间不足导致备份失败，数据丢失的恶果！ 存储到当前磁盘这是最简单，却是最不推荐的；服务器有多块硬盘，最好是把备份存放到另一块硬盘上；有条件就选择更好更安全的存储介质；1# df -h 12345Filesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup-lv_root 50G 46G 1.6G 97% /tmpfs 1.9G 92K 1.9G 1% /dev/shm/dev/sda1 485M 39M 421M 9% /boot/dev/mapper/VolGroup-lv_home 534G 3.6G 503G 1% /home 2、创建备份目录：上面我们使用命令看出/home下空间比较充足，所以可以考虑在/home保存备份文件；123cd /homemkdir backupcd backup 3、创建备份Shell脚本:注意：把以下命令中的DatabaseName换为实际的数据库名称； 当然，你也可以使用其实的命名规则！1vi bkDatabaseName.sh 输入/粘贴以下内容：12#!/bin/bashmysqldump -uusername -ppassword DatabaseName &gt; /home/backup/DatabaseName_$(date +%Y%m%d_%H%M%S).sql 对备份进行压缩：12#!/bin/bashmysqldump -uusername -ppassword DatabaseName | gzip &gt; /home/backup/DatabaseName_$(date +%Y%m%d_%H%M%S).sql.gz 注意： 把 username 替换为实际的用户名； 把 password 替换为实际的密码； 把 DatabaseName 替换为实际的数据库名； 4、添加可执行权限：1chmod u+x bkDatabaseName.sh 添加可执行权限之后先执行一下，看看脚本有没有错误，能不能正常使用；1./bkDatabaseName.sh 5、添加计划任务5.1 检测或安装 crontab确认crontab是否安装： 执行 crontab 命令如果报 command not found，就表明没有安装12# crontab-bash: crontab: command not found 如时没有安装 crontab，需要先安装它，具体步骤请参考： CentOS下使用yum命令安装计划任务程序crontab 使用rpm命令从CentOS系统盘安装计划任务程序crontab 5.2 添加计划任务执行命令：1crontab -e 这时就像使用vi编辑器一样，可以对计划任务进行编辑。 输入以下内容并保存：1*/1 * * * * /home/backup/bkDatabaseName.sh 具体是什么意思呢？ 意思是每一分钟执行一次shell脚本“/home/backup/bkDatabaseName.sh”。 6、测试任务是否执行很简单，我们就执行几次“ls”命令，看看一分钟过后文件有没有被创建就可以了！ 如果任务执行失败了，可以通过以下命令查看任务日志：1# tail -f /var/log/cron 输出类似如下：12345678910Sep 30 14:01:01 bogon run-parts(/etc/cron.hourly)[2503]: starting 0anacronSep 30 14:01:01 bogon run-parts(/etc/cron.hourly)[2512]: finished 0anacronSep 30 15:01:01 bogon CROND[3092]: (root) CMD (run-parts /etc/cron.hourly)Sep 30 15:01:01 bogon run-parts(/etc/cron.hourly)[3092]: starting 0anacronSep 30 15:01:02 bogon run-parts(/etc/cron.hourly)[3101]: finished 0anacronSep 30 15:50:44 bogon crontab[3598]: (root) BEGIN EDIT (root)Sep 30 16:01:01 bogon CROND[3705]: (root) CMD (run-parts /etc/cron.hourly)Sep 30 16:01:01 bogon run-parts(/etc/cron.hourly)[3705]: starting 0anacronSep 30 16:01:01 bogon run-parts(/etc/cron.hourly)[3714]: finished 0anacronSep 30 16:15:29 bogon crontab[3598]: (root) END EDIT (root)","tags":[]},{"title":"mysql主从复制","date":"2017-06-05T01:36:46.000Z","path":"2017/06/05/mysql主从复制/","text":"非常简单的mysql主从复制1、主从服务器分别作以下操作： 1.1、版本一致 1.2、初始化表，并在后台启动mysql 1.3、修改root的密码 2、修改主服务器master:1234#vi /etc/my.cnf[mysqld]log-bin=mysql-bin //[必须]启用二进制日志server-id=222 //[必须]服务器唯一ID，默认是1，一般取IP最后一段 3、修改从服务器slave:1234#vi /etc/my.cnf[mysqld]log-bin=mysql-bin //[不是必须]启用二进制日志server-id=226 //[必须]服务器唯一ID，默认是1，一般取IP最后一段 4、重启两台服务器的mysql1service mysqld restart 5、在主服务器上建立帐户并授权slave: 进入mysql 1mysql -uroot -proot 建立账号admin，密码123，并授权slave 1mysql&gt;GRANT REPLICATION SLAVE ON *.* to &apos;admin&apos;@&apos;%&apos; identified by &apos;123&apos;; //一般不用root账号 注意：其中%表示所有客户端都可连，只要帐号，密码正确，此处可用具体客户端IP代替，如’admin’@’192.168.1.226’，加强安全 6、登录主服务器的mysql，查询master的状态1mysql&gt;show master status 123456+------------------+----------+--------------+------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000004 | 308 | | |+------------------+----------+--------------+------------------+1 row in set (0.00 sec) 注意：执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化 7、配置从服务器Slave：12mysql&gt;change master to master_host=&apos;192.168.145.222&apos;,master_user=&apos;admin&apos;,master_password=&apos;123&apos;,master_log_file=&apos;mysql-bin.000004&apos;,master_log_pos=308; 注意：master_host为你主服务器IP地址，master_log_file为你主服务器查询的File名，master_log_pos为你主服务器查询的Position 8、开启并检查从服务器复制功能状态： 开启从服务器slave 1Mysql&gt;start slave; //启动从服务器复制功能 检查从服务器复制功能状态 1mysql&gt; show slave status\\G 123456789101112131415*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.2.222 //主服务器地址 Master_User: admin //授权帐户名，尽量避免使用root Master_Port: 3306 //数据库端口，部分版本没有此行 Connect_Retry: 60 Master_Log_File: mysql-bin.000004 Read_Master_Log_Pos: 600 //#同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos Relay_Log_File: ddte-relay-bin.000003 Relay_Log_Pos: 251 Relay_Master_Log_File: mysql-bin.000004 Slave_IO_Running: Yes //此状态必须YES Slave_SQL_Running: Yes //此状态必须YES .....","tags":[]},{"title":"git技术分享","date":"2017-06-02T08:09:29.000Z","path":"2017/06/02/git技术分享/","text":"1、安装git图文界面版： http://msysgit.github.com/一路下一步即可，即有小黑框又有图形界面 小黑框版： 从Git官网下载windows版本的git：http://git-scm.com/downloads 一般使用默认设置即可：一路next，git安装完毕！ 但是如果这时你打开windows的cmd，在里面打git命令会提示“不是内部或外部命令，也不是可运行的程序”，想要直接在windows的cmd里使用git命令要多加如下两步 找到git安装路径中bin的位置，如：D:\\Program Files\\Git\\bin 找到git安装路径中git-core的位置，如：D:\\Program Files\\Git\\libexec\\git-core; 注：”D:\\Program Files\\Git\\”是安装路径，可能与你的安装路径不一样，要按照你自己的路径替换”D:\\Program Files\\Git\\” 右键“计算机”-&gt;“属性”-&gt;“高级系统设置”-&gt;“环境变量”-&gt;在下方的“系统变量”中找到“path”-&gt;选中“path”并选择“编辑”-&gt;将3.1种找到的bin和git-core路径复制到其中-&gt;保存并退出 注：“path”中，每个路径之间要以英文输入状态下的分号——“;”作为间隔 现在就可以在cmd里尽情的使用git了~ 2、创建用户名和邮箱1git config --gloabal user.name &quot;xxxxxxxx&quot; 1git config --gloabal user.email &quot;xxxxxxxx@xxxx.xxx&quot; 3、建立版本仓库1git init 4、在仓库的工作区创建文件、添加到缓存区、提交到版本仓库 vim 1.php 创建 git add 1.php 添加到缓存区 git status 查看当前工作区的状态 git diff HEAD – 1.php 查看当前修改和版本库中文件的差别 git commit -m ‘版本修改说明’ 5、版本回退 git log 查看所有的版本信息 git reset –hard HEAD^ 回到上一版本 git reset –hard HEAD^^ 回到上上一版本 git reset –hard 版本ID git reflog 查看版本操作命令（方便进行版本回到未来的操作） 6、撤销工作区内容的修改（在commit之前）(已经add但没有提交)1git reset HEAD 1.php (未提交之前的修改)1git checkout -- 1.php 会回退到最初的工作区的状态 但一旦提交到了版本仓库了之后，那就使用 git rest –hard 版本ID 来实现版本的回退，尽量不要托管到远程仓库再进行修改 总结： 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 7、删除文件 1）先在本地文件管理目录进行删除 git rm 1.php 然后提交到版本仓库 git commit -m ‘delete 1.php’ 实现本地和版本仓库的一致性 2）撤回删除 git checkout – 1.php 8、远程仓库第1步：生成秘钥文件 1ssh-keygen -t rsa -C &quot;lau0400810121@163.com&quot; 一路下一步，最终在”C:\\Users\\hasee.ssh“下看到2个文件 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 第3步：团队开发，添加多个ssh key 9、添加远程仓库在github上创建一个新的仓库，假设仓库名称为study 本地库与远程库建立联系 1git remote add origin git@github.com:自己的github账号名/study.git 把本地仓库下的内容推送到GitHub仓库中 1git push -u origin master 把本地master分支推送到远程仓库的master分支中 1git push -u origin master:developer 把本地master分支推送到远程仓库的developer分支中,再在远程master中进行合并 以后只要本地做了提交到本地版本库，就可以使用下面命令推送到GitHub 1git push origin master 假如远程仓库已经有了文件了，先得同步到本地 1git pull --rebase origin master 或者 1git rebase orgin master 从github拉取下来最新的和本地进行合并 1git pull origin dev 从远程的dev分支上拉取到本地的master分支上 如果远程仓库走的是https协议，必须输入仓库的用户名和密码 如果是ssh协议，则不需要，前提是初始化时的用户名和邮箱必须和远程仓库的保持一致 10、从远程库中克隆在github上创建一个新的版本仓库，命名为mygit 克隆远程仓库到本地形成一个本地仓库 git clone git@github.com:GitHub账号/mygit.git（既可以是git@github.com，也可以是https://github.com/GitHub账号/mygit.git） 然后在本地的mygit库中查看同步的文件 11、分支创建并切换到新分支1git checkout -b dev 相当于： git branch dev(创建) git checkout dev(切换) git branch 查看当前分支 分支合并: 1.首先切换到主分支上1git checkout master 2.在主分支上进行合并1git merge dev 3.分支删除：1git branch -d dev 12、冲突解决 当在一个分支上修改一个文件提交到分支版本库时，同时主分支也进行修改该文件并进行提交，接着进行合并时就会出现冲突 直接在主分支上打开冲突文件（可以使用git status查看），并进行相应的修改，最后提交即可 删除分支 以下命令可以看到分支合并图 1git log --graph --pretty=oneline --abbrev-commit 13、分支处理策略master分支只作为发布版本，平时不在上面操作 dev分支用来做开发使用，每个人往dev分支上开发，最后进行合并1git merge --no-ff -m &quot;merge with no-ff&quot; dev 14、BUG分支假定手头有分工作正在dev分支上操作，但是没有完成，但此时需要修复BUG 可以先隐藏当前的分支1git stash 通过查看工作区1git status 假设需要在主分支上修复BUG，此时切换到主分支上去1git checkout master 在主分支上创建BUG分支1git checkout -b bug_01 在BUG分支完成修改提交后，切换到主分支进行合并并删除掉BUG分支 接着重新跳到dev分支上工作1git checkout dev 重新返回到原工作区1git stash pop 15、强行删除（一个未合并的）分支1git branch -D feature-vulca 16、多人操作查看远程仓库1git remote -v 推送分支1git push origin master 1git push origin dev master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 17 多人协作开发 多人协作的工作模式通常是这样： 首先，可以试图用推送自己的修改； 1git push origin branch-name 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name 18、打标签方面更好的查找，比版本ID更容易记 在指定分支上添加标签 1git tag v1.0 查找所有的标签 1git tag 查看所有的版本信息 1git log --pretty=oneline --abbrev-commit 创建带有说明的标签 1git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 查看标签信息 1git show v0.1 删除标签 1git tag -d v0.1 推送标签到远程 12git push origin v0.1git push origin --tags 删除已经推送到远程的标签 先在本地删除 1git tag -d v0.1 再删除远程 1git push origin :refs/tags/v0.1 19、搭建git服务器第一步，安装git1yum -y install git 第二步，创建git用户来管理git1adduser git 第三步，创建证书登陆 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令 1git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： 1chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： 1git:x:1001:1001:,,,:/home/git:/bin/bash 改为： 1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 第六步，克隆远程仓库：1git clone git@server:/srv/sample.git","tags":[]},{"title":"blog","date":"2017-04-06T08:58:02.000Z","path":"2017/04/06/git远程仓库/","text":"第五章节 远程仓库4-1 申请远程仓库账号如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。本章开始介绍Git的杀手级功能之一__远程仓库。 Git仓库的托管服务，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 Github 官网：https://github.com/ 码云 官网：https://git.oschina.net/ 请自行注册GitHub或码云账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对， id_rsa是私钥，不能泄露出去。 id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： Q：问为什么GitHub需要SSH Key呢？ A：因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 小结 “有了远程仓库，妈妈再也不用担心我的硬盘了。 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 4-2 添加远程库首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 把本地仓库的内容推送到GitHub仓库。现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：1$ git remote add origin https://github.com/DBING/bingproject.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上：如果是本地建的仓库，由于没有README.md文件，需要把远程的这个文件和当前的仓库的文件进行合并，运行下面代码 1git pull --rebase origin master 1234567$ git push -u origin masterCounting objects: 34, done.Delta compression using up to 4 threads.Compressing objects: 100% (22/22), done.Writing objects: 100% (34/34), 2.85 KiB | 0 bytes/s, done.Total 34 (delta 8), reused 0 (delta 0)remote: Resolving deltas: 100% (8/8), done. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令：1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 4-2 从远程库克隆上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitlearn：","tags":[]}]